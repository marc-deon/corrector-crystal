# TODO
- [ ] New paramters for actions
    - [?] hitStop
    - [?] forceAir
    - [ ] overrideGravity
    - [?] knockback
    - [?] airKnockback
    - [ ] knockbackFrames
    - [ ] selfKnockback
    - [ ] selfKnockbackFrames
    - [ ] wallSplat
    - [ ] dunk
    - [ ] slam
- [-] Documentation (Partially done)
- [ ] Change hard coded action indices to be named... I think

#######################################
Stun meter. Gaurd meter. Not a huge fan of either, BUT...
consider that you some moves could raise/drain your own stun/gaurd.
Use these to extend pressure, at the risk of weakening your defense if it fails.

#######################################
<!-- # LLScript
- Group commands with {}
- Seperate commands with newline

## Available to LLScript authors:
### keyword variables:
- self
- opponent
- var
- red
- white
### key functions
- moveBy(x,y)
- damage(target, amount, type=red/white)
- stun(target) <!-- // Only 1 frame at a time - ->
- setState(state)

<!-- - moveto(x,y) - ->
### flow control
- if(cond)
- while(cond)
- for varName(init, final, inc)
- wait() <!-- sleep 1 frame - ->
-->
#######################################
# Knockback

Fun shit. How does it work? Dunno.

1. Hitpause
2. Set state (don't change/force air)
3. Velocity stuff
    1. Set velocity, regular physics (most normals)
    2. Set velocity, disable physics for a time (?)
    3. Set velocity, disable physics until wall/ground (wallsplats)
    4. Set velocity & temp gravity for a time (?)
    5. Set velocity & temp gravity until wall/ground (launchers)
4. Exit

We... might have to make a scripting language. Lazy Llama Script, or llscript for short.
That is a HELL of a lot of work, though, so let's try to just get it in the current
system first.

This will require adding a lot extra to actions, so we need to add optional action
parameters and defaults. This is the idle animation before that; better,
more permanent documentation should be made promptly.

Required fields marked with stars.

     *name: "Idle",
    linksTo: null,
    mustLinkAfter: -1,
    state: 0,
     *priority: 0,
     *animation: "Idle",
    damage: 1000,
    hitstun: 40,
    hitStop: 0,           // NEW: Time before knockback happens
    forceAir: false,       // NEW: Force opponent into air upon hitbox connection (for launchers)
    overrideGravity:[0,0], // NEW: Override the character gravity with this new
                                // gravity until opponent collides with wall/floor, or is hit
                                // (for wallsplats, launchers, dunks, against airborn)
    knockback:[0,0],       // NEW: XY knockback per frame. On block can maybe be doubled or something.
    airKnockback:[0,0],    // NEW: Knockback against an airborn opponent
    knockbackFrames:0,     // NEW: How many frames knockback lasts.
    selfKnockback: [0,0],  // NEW: Self
    selfKnockbackFrames: 0,// NEW: Self
    wallSplat: false,      // NEW: Go to tech state upon touching wall
    dunk: false,           // NEW: Go to tech state upon touching ground
    slam: false,           // NEW: Hard knockdown upon touching ground
     *hitboxes: [],
     *hurtboxes: [[-25, -110, 50, 110]],
     *shovebox: [-20, -60, 40, 60]

In melty:
(1)Grounded moves set a self and opp knockback, horizontal only, unless they
(2)launch, wallsplat, or (3)force airborn (w/o launch or wallsplat, so it just works as a regular air move).

(4)Air moves work the same as grounded moves, but are generalyl done air to air.
dfci has dunks which is really just a wallsplat against the ground.

These can be implemented as:
1. Custom knockback, default airKnockback, default overrideGravity
2. 0 knockback, custom airKnockback, forceAir, custom overRideGravity
3. Custom knockback, default airKnockback, forceAir, default overrideGravity
4. Same as 1

If you want
#######################################
# General goals
I never really had a plan for this project, but I figure there should be a goal
at some point. So, maybe I won't still want this in 3 months, but I think
there's room in the market for a game like Fantasy Strike for anime games.
Two attack buttons, two specials, two+ macros (grab/dash/burst/roman cancel).
...
(2020-7-27)
The problem here is that anime is almost by definition more complex than other
subgenres. Whether you define anime by combo length, movement options,
character gimmicks, global meters/systems, or pressure strength, it always has
more upfront complexity than SF style games. The one listed aspect there that
may be shared is the character gimmicks; Fantasy Strike has gimmicks.

Personally, there's 3 unique things that I really enjoy about anime games:
1. Air movement
2. Pressure strings
3. Meter management
Air movement and air footsies I think is a no brainer to include; imo that's
the thing that *really* distinguishes anime from SF. Having lots of different
meters I think is out; it's too front loaded, even if the meters aren't all
that complicated. Pressure can be simple or complex in a number of ways.
I think, though, adding a discrete resource and designing around that would
help. So let's say this:
    Each player has X number of luck cards. They regen over time up to a max.
    These can be used in one of two (three?) ways:
        1. Defensively (When activated in blockstun)
        2. Offensively (When activated outside of blockstun)
        3. ..........? (When activated in idle)
    Defensive luck acts like pushblock, maybe also give slight frame advantage.
    Offensive luck acts like chainshift, canceling current action with a pause.
These may still take a couple minutes to really understand for the players,
but I think it can help the designers avoid ridiculous pressure like Arc
and Roa have.

With that in mind, then, the controls would look like this:
A B M1
X Y M2
As of writing this, I'm having a hard time deciding M1 and M2;
Luck should absolutely be one of them, but I also want both grab and airdash to
be available on single buttons... Although, given that:
    1. I use 7 buttons
    2. Most stick players have 8 available
    3. Pad players definitely have 8 available
it might not be too bad to just design for 7 (Hey, it's playable on gamecube!).
In that case:
A B L AD
X Y G
Where A and B are regular attacks, X and Y are specials,
L is Luck, G is grab, and AD is (air)dash.

The options menu will allow L, G, and AD to be set to single buttons, a pair,
or both, not unlike how Fantasy Strike allows. 66 and 44 for dashes will also
be able to be toggled on, just as FS allows for jump on up to be toggled on.

Grab works similarly to in Kyanta; hold the button to buffer grab, and when
you're in range it will grab. If both players have buffer, a tech will happen.


#######################################
# Motion & Action priorities
Priorities are just numbers within blocks (this is just a baseline; exceptions are fine):
    
    0 Idle, crouch
    1+ Basic movement
    10+ Light normals
    20+ Medium normals
    30+ Heavy normals
    40+ Specials (jump cancelable)

    50  Jump
    51+ Specials (no jc)

    60+ Air Lights
    70+ Air Mediums
    80+ Air Heavys
    90+ Air specials (djc)

    100 Double jump
    101 Air dash
    102+ Air specials (no djc)

    110+ EX specials
    120+ Supers
    130  Air throw

    1000 Stagger

Air dash canceling will be interesting, because I want to preserve the ability
to do j.C ADC j.C. So let's propose the following solution:
    Negative priority actions can cancel into anything, and be canceled into from any action with an absolute priority lower than the negative action.
    Valid chain:
        j.C (80) ADC (-101) J.C (80) Super (120)
    Invalid chain:
        J.C (80) Super (120) (!) ADC (-100) Super (120)
    The second chain is invalid because |120| is greater than |-100|.

Also, as a special case for walking forward/backward, priority 1 can be canceled into priority 1.
*This is neccesary to avoid moonwalking.* Make sure to use this for every character.


#######################################
# States!

typedef struct hitbox {
    Rectangle rect;
    
    // This can't be derived from other data, because we set it
    // to false whenever the hitbox hits a target.
    bool active; 
    uint activeOnFrame;
    uint offOnFrame;

    int mustLinkAfter;
    uint currentFrames;
} Hitbox;

typedef struct hurtbox{
    Rectangle rect;
} Hurtbox;

typedef struct shovebox{
    Rectangle rect;
} Shovebox;



typedef enum {
    FS_NONE        = 0x0,
    FS_AIR         = 0x1, // Field is 0 if grounded
    FS_ATTK_INVULN = 0x2,
    FS_PROJ_INVULN = 0x4,
    FS_GRAB_INVULN = 0x8,

    FS_FULL_INVULN = 0x2 + 0x4 + 0x8,
    // Others?

} FighterState;

/*
Everything a character does is an Action: standing, walking, blocking, attacking,
they're all actions. 99% of the time you see an animation change, 
it's because the current action changed.
*/
struct Action {
    // Human readable name
    char* name;  

    // Total accumulated frames since entering action
    uint currentFrame; 
    // Action will automatically link to another action (generally idle) after this many frames.
    // mustLinkAfter is modified by opponent in cases such as getting hit.
    int mustLinkAfter; 
    struct Action* linksTo;

    // Upon entering the, the fighter's state will become this flag set.
    // If multiple flag sets are needed (e.g. backdash being invuln), use multiple actions.
    FighterState state;

    // Actions can be canceled into other actions with higher priority
    // e.g. jabs into straights, regular into special, hitstun into burst.
    uint priority; 

    // Animation to play upon entering action
    Animation* animation; 
    // Stretchy buffer; fighter does not directly have hitboxes
    Hitbox[] hitboxes;    
    // Stretchy buffer; fighter does not directly have hurtboxes
    Hurtbox[] hurtboxes;  
    // AKA collision box
    Shovebox shovebox;
}

Possible states (with duplicates):
    Grounded
        - Attacking
        - Blocking
        - Hit Stun
        - Teching
        - Invulnerable
        - Dashing
        Crouching (Derived)

    
    Aerial
        - Attacking
        - Blocking
        - Hit Stun
        - Teching
        - Invulnerable
        - Dashing

----------------
Alternative idea: Use non-stacking states and stackable flags.
    Flags:
        Grounded
        Aerial
        Invuln

    States:
        Idle
        Dashing
        Attacking
        Blocking
        Hit Stun

#######################################

Input works like this:

Physical button -> OS -> HandleInput() [for now] -> IsKeyDown -> StickState -> StickState Functions
[        block 1       ] [               block 2               ] [             block 3             ]
Block 1 is out of my control. Block 2 and 3 should each be factored out of main.c and into at least one file each, and then possibly organized further.

Essentially, I want blocks to use the ones underneath them:
    Block X: Main thread
    Block 3: Genre specific input (CC_Input)
    Block 2: Input framework; also used for debug, alt-F4, etc (QFramework_Input)
    Block 1: SDL
    BLock 0: Hardware and OS

----------------------------
I probably want to have similar collections of convenience functions for video and audio.


#######################################

The Format of these patterns is a little different from regular numpad notation.
Numbers are used for directions, And ABC-XYZ are used for buttons.
Additionally, P may be used to represent any XYZ, and K any ABC. This allows, for example, pushblock to be any P+P instead of needing to specify.
Charge moves are notated with the regular square brackets, with the number of frames specifed after a hyphen,
e.g. [4-30]6C is a sonic boom motion that requires 30 frames of charging.

Standard notation does nothing to specify if two buttons need to be pressed on the same frame, i.e. 6C vs 236C.
The expectation is that 6C requires both buttons be pressed on the same frame (it's a command normal), while 236C allows for a small pause between 6 and C (it's a motion).

This is fine for humans, who can fill in that gap with an assumption. It's not enough for computers, however.
This notation makes it more explicit by grouping same-frame inputs with parentheses. So for example:
    A common fireball is notated as 236A.
    A common overhead command normal is notated as (6C).
    A common launcher is notated as (3C) ((26C) will also work, but due both to length and convention is not prefered).
    Talbain super is XY6AB (regularly notated as LP MP 6 LK MK).
    Common 6 button grabs are notated as (AX) (regularly LP+LK), (PP) (regularly P+P), or (6Z) (regularly 6HP).
